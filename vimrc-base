
let g:clj_fmt_config_dir = '.lein/profiles.clj'
let g:python3_host_prog = '/usr/local/bin/python3'

" ---------------------------- Repl Alliance ------------------------------------
"
autocmd FileType clojure lua repl = require("unrepl"):connect()

let g:replPort = 3722
let g:replHost = "127.0.0.1"
let g:replNamespace = "user"
let g:replProtocol = "unrepl"
let g:replVirtual = 1000
let g:replElision = "●"

" ----------------------------------------------------------------
" modify selected text using combining diacritics
command! -range -nargs=0 Overline        call s:CombineSelection(<line1>, <line2>, '0305')
command! -range -nargs=0 Underline       call s:CombineSelection(<line1>, <line2>, '0332')
command! -range -nargs=0 DoubleUnderline call s:CombineSelection(<line1>, <line2>, '0333')
command! -range -nargs=0 Strikethrough   call s:CombineSelection(<line1>, <line2>, '0336')

function! s:CombineSelection(line1, line2, cp)
  execute 'let char = "\u'.a:cp.'"'
  execute a:line1.','.a:line2.'s/\%V[^[:cntrl:]]/&'.char.'/ge'
endfunction
" ----------------------------------------------------------------
" Customize fzf colors to match your color scheme
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

function! s:fzf_statusline()
  " Override statusline as you like
  highlight fzf1 ctermfg=161 ctermbg=251
  highlight fzf2 ctermfg=23 ctermbg=251
  highlight fzf3 ctermfg=237 ctermbg=251
  setlocal statusline=%#fzf1#\ >\ %#fzf2#fz%#fzf3#f
endfunction

autocmd! User FzfStatusLine call <SID>fzf_statusline()

" feed Ag into fzf
command! -bang -nargs=* Ack call fzf#vim#ag(<q-args>, {'down': '40%', 'options': --no-color'})

call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#custom#source(
        \ 'file', 'matchers',
        \ ['matcher_default', 'matcher_hide_hidden_files',
        \  'matcher_hide_current_file',
        \  'matcher_project_ignore_files'])

set enc=utf-8
set scroll=5
set scrolloff=7

let g:gitgutter_override_sign_column_highlight = 0

"------------------------------------- prettier ---------------------------------
let g:prettier#config#bracket_spacing = 'true'
"------------------------------------- neomake ---------------------------------
let g:neomake_javascript_eslint_exe = '/usr/local/bin/eslint'
let g:neomake_javascript_enabled_makers = ['eslint']
augroup my_neomake_signs
    au!
    autocmd ColorScheme *
        \ hi NeomakeErrorSign ctermfg=red |
        \ hi NeomakeWarningSign ctermfg=yellow |
        \ hi NeomakeMessageSign ctermfg=blue |
        \ hi NeomakeInfoSign ctermfg=green
augroup END
let g:neomake_warning_sign = {'text': '⚠', 'texthl': 'NeomakeWarningSign'}
let g:neomake_error_sign = {'text': '✕', 'texthl': 'NeomakeErrorSign'}
let g:neomake_message_sign = {'text': '➤','texthl': 'NeomakeMessageSign'}
let g:neomake_info_sign = {'text': 'ℹ','texthl': 'NeomakeInfoSign'}
autocmd! BufWritePost * Neomake

"------------------------------------- deoplete --------------------------------
"
set runtimepath+=~/.vim/bundle/deoplete.nvim/
let g:deoplete#enable_at_startup = 1
let g:deoplete#keyword_patterns = {}
" call deoplete#custom#option('keyword_patterns', {'clojure': '[\w!$%&*+/:<=>?@\^_~\-\.#]*'})
let g:deoplete#keyword_patterns.clojure = '[\w!$%&*+/:<=>?@\^_~\-\.]*'
let g:deoplete#enable_smart_case = 1

" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-j> deoplete#mappings#smart_close_popup()
inoremap <expr><C-j>   pumvisible() ? "\<C-n>" : "\<C-j>"
inoremap <expr><C-k>   pumvisible() ? "\<C-p>" : "\<C-k>"

"-------------------------------- lightline / bufferline -----------------------
set noshowmode
set showtabline=2
autocmd BufWritePost,TextChanged,TextChangedI * call lightline#update()
let g:lightline = {'colorscheme': 'solarized'}
let g:lightline.tabline          = {'left': [['buffers']]}
let g:lightline.component_expand = {'buffers': 'lightline#bufferline#buffers'}
let g:lightline.component_type   = {'buffers': 'tabsel'}
let g:lightline.separator = {'left': '', 'right': ''}
let g:lightline.subseparator = {'left': '┃', 'right': '│'}
let g:lightline#bufferline#filename_modifier = ':t'
let g:lightline#bufferline#enable_devicons = 1
let g:lightline#bufferline#unicode_symbols = 1
" branch: E0A0
" "ln" symbol: E0A1
" lock: E0A2
"------------------------------------- Ultisnips --------------------------------
let g:UltiSnipsUsePythonVersion = 3
let g:UltiSnipsEditSplit = 'vertical'
let g:UltiSnipsExpandTrigger='<tab>'
let g:UltiSnipsJumpForwardTrigger='<tab>'
let g:UltiSnipsJumpBackwardTrigger='<s-tab>'

" let g:user_emmet_leader_key='`'
let g:user_emmet_expandabbr_key = '§'

let g:highlightedyank_highlight_duration = 500

let $NVIM_TUI_ENABLE_TRUE_COLOR=1

set laststatus=1

let g:agprg="ag --column --smart-case -U"

scriptencoding utf-8

set nocompatible
set incsearch
set hidden

set tabstop=4
set softtabstop=4
set shiftwidth=4
set smarttab
set expandtab
set autoindent
set laststatus=2

" don't use swapfiles. Use git instead
set nobackup
set nowritebackup
set noswapfile
set hlsearch

" allways use OSX's clipboard
set clipboard=unnamed

" Sets how many lines of history VIM has to remember
set history=700
set nofoldenable

" show linenumbers
set number

" highlight tabs and trailing spaces
set list listchars=tab:››,eol:¬,trail:·
set nolist

" highlight NonText guifg=#80a0ff ctermfg=Black
" highlight Whitespace guifg=#ff0000
" highlight EndOfBuffer guifg=#ff0000

" Set to auto read when a file is changed from the outside
set autoread

set termguicolors
set t_Co=256

" hilight search/replace
set inccommand=nosplit

" allow NerdTree to set the Working Directory correctly
let NERDTreeChDirMode=2

augroup file_type
    autocmd!
    " When vimrc is edited, reload it
    autocmd bufwritepost nested vimrc source ~/.vim/vimrc
    autocmd BufNewFile,BufRead *.json set ft=javascript
    autocmd BufNewFile,BufRead *.coffee set ft=coffee
    autocmd BufNewFile,BufRead *.less,*.scss,*.styl set ft=css
    autocmd BufNewFile,BufRead *.boot,*.cljs,*.edn set ft=clojure
augroup end

syntax on
set guioptions=-t " don't show the menu
set guioptions=+R " show scrollbar
set hlsearch
set ch=2          " Make command line two lines high
set mousehide     " Hide the mouse when typing text
set guifont=FiraCode-Regular:h11
set background=dark

colorscheme NeoSolarized

function! ExecuteMacroOverVisualRange()
    echo "@".getcmdline()
    execute ":'<,'>normal @".nr2char(getchar())
endfunction

let g:darkColorScheme=1
function! ToggleLightDarkColorscheme()
    if g:darkColorScheme
        set background=light
        let g:darkColorScheme=0
    else
        set background=dark
        let g:darkColorScheme=1
    endif
endfunction


" Strip trailing whitespace
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction

" check/uncheck Todo-Items that look like this:
" [ ] mow the lawn
function! ToggleDone()
    if search('\[x\]', 'bcn', line("."))
        call Preserve('.s/\[x\]/\[ \]/')
    elseif search('\[ \]', 'bcn', line("."))
        call Preserve('.s/\[\s\]/\[x\]/')
    endif
endfunction

let g:zenMode=0
function! ToggleZenMode()
    if g:zenMode
        set number
        GitGutterEnable
        let g:zenMode=0
    else
        set nonumber
        GitGutterDisable
        let g:zenMode=1
    endif
endfunction
